## 2020년 10월 4주차 알고리즘

1. **쿼드 압축 후 개수 세기 [68936](https://programmers.co.kr/learn/courses/30/lessons/68936)**

###### **문제 설명**

0과 1로 이루어진 2n x 2n 크기의 2차원 정수 배열 arr이 있습니다. 당신은 이 arr을 [쿼드 트리](https://en.wikipedia.org/wiki/Quadtree)와 같은 방식으로 압축하고자 합니다. 구체적인 방식은 다음과 같습니다.

1. 당신이 압축하고자 하는 특정 영역을 S라고 정의합니다.
2. 만약 S 내부에 있는 모든 수가 같은 값이라면, S를 해당 수 하나로 압축시킵니다.
3. 그렇지 않다면, S를 정확히 4개의 균일한 정사각형 영역(입출력 예를 참고해주시기 바랍니다.)으로 쪼갠 뒤, 각 정사각형 영역에 대해 같은 방식의 압축을 시도합니다.

arr이 매개변수로 주어집니다. 위와 같은 방식으로 arr을 압축했을 때, 배열에 최종적으로 남는 0의 개수와 1의 개수를 배열에 담아서 return 하도록 solution 함수를 완성해주세요.

###### **제한사항**

- arr의 행의 개수는 1 이상 1024 이하이며, 2의 거듭 제곱수 형태를 하고 있습니다. 즉, arr의 행의 개수는 1, 2, 4, 8, ..., 1024 중 하나입니다.
  - arr의 각 행의 길이는 arr의 행의 개수와 같습니다. 즉, arr은 정사각형 배열입니다.
  - arr의 각 행에 있는 모든 값은 0 또는 1 입니다.

###### **입출력 예**

| arr                                                          | result    |
| ------------------------------------------------------------ | --------- |
| `[[1,1,0,0],[1,0,0,0],[1,0,0,1],[1,1,1,1]]`                  | `[4,9]`   |
| `[[1,1,1,1,1,1,1,1],[0,1,1,1,1,1,1,1],[0,0,0,0,1,1,1,1],[0,1,0,0,1,1,1,1],[0,0,0,0,0,0,1,1],[0,0,0,0,0,0,0,1],[0,0,0,0,1,0,0,1],[0,0,0,0,1,1,1,1]]` | `[10,15]` |

###### **입출력 예 설명**

**입출력 예 #1**

- 다음 그림은 주어진 arr을 압축하는 과정을 나타낸 것입니다.
- ![ex1.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/d6900862-8be4-4610-aaef-bc8efd5650cf/ex1.png)
- 최종 압축 결과에 0이 4개, 1이 9개 있으므로, `[4,9]`를 return 해야 합니다.

**입출력 예 #2**

- 다음 그림은 주어진 arr을 압축하는 과정을 나타낸 것입니다.
- ![ex2.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/952a05b7-5157-4211-82d9-02845c187e13/ex2.png)
- 최종 압축 결과에 0이 10개, 1이 15개 있으므로, `[10,15]`를 return 해야 합니다.

###### **풀이법**

정사각형을 1/4로 나누어나가면서 조각이 같은 값을 갖고 있으면 압축하고 마지막에 0또는 1을 리턴한다.

```java
private static void dfs(int n, int x, int y) {
    if (n == 1) { // 한개인 경우 해당 값 +
        if (map[x][y] == 1) {
            one++;
        } else {
            zero++;
        }
        return;
    }
    if (isSame(n, x, y)) { //같은값인지 압축 가능한지
        return;
    }
    //4개 분리 탐색
    dfs(n / 2, x, y);
    dfs(n / 2, x + n / 2, y);
    dfs(n / 2, x, y + n / 2);
    dfs(n / 2, x + n / 2, y + n / 2);
}
```

-----

2. **n진수 게임 [17687](https://programmers.co.kr/learn/courses/30/lessons/17687)**

###### **문제 설명**

튜브가 활동하는 코딩 동아리에서는 전통적으로 해오는 게임이 있다. 이 게임은 여러 사람이 둥글게 앉아서 숫자를 하나씩 차례대로 말하는 게임인데, 규칙은 다음과 같다.

1. 숫자를 0부터 시작해서 차례대로 말한다. 첫 번째 사람은 0, 두 번째 사람은 1, … 열 번째 사람은 9를 말한다.
2. 10 이상의 숫자부터는 한 자리씩 끊어서 말한다. 즉 열한 번째 사람은 10의 첫 자리인 1, 열두 번째 사람은 둘째 자리인 0을 말한다.

이렇게 게임을 진행할 경우,
`0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 0, 1, 1, 1, 2, 1, 3, 1, 4, …`
순으로 숫자를 말하면 된다.

한편 코딩 동아리 일원들은 컴퓨터를 다루는 사람답게 이진수로 이 게임을 진행하기도 하는데, 이 경우에는
`0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, …`
순으로 숫자를 말하면 된다.

이진수로 진행하는 게임에 익숙해져 질려가던 사람들은 좀 더 난이도를 높이기 위해 이진법에서 십육진법까지 모든 진법으로 게임을 진행해보기로 했다. 숫자 게임이 익숙하지 않은 튜브는 게임에 져서 벌칙을 받는 굴욕을 피하기 위해, 자신이 말해야 하는 숫자를 스마트폰에 미리 출력해주는 프로그램을 만들려고 한다. 튜브의 프로그램을 구현하라.

###### **입력 형식**

진법 `n`, 미리 구할 숫자의 갯수 `t`, 게임에 참가하는 인원 `m`, 튜브의 순서 `p` 가 주어진다.

- 2 ≦ `n` ≦ 16
- 0 ＜ `t` ≦ 1000
- 2 ≦ `m` ≦ 100
- 1 ≦ `p` ≦ `m`

###### **출력 형식**

튜브가 말해야 하는 숫자 `t`개를 공백 없이 차례대로 나타낸 문자열. 단, `10`~`15`는 각각 대문자 `A`~`F`로 출력한다.

###### **입출력 예제**

| n    | t    | m    | p    | result           |
| ---- | ---- | ---- | ---- | ---------------- |
| 2    | 4    | 2    | 1    | 0111             |
| 16   | 16   | 2    | 1    | 02468ACE11111111 |
| 16   | 16   | 2    | 2    | 13579BDF01234567 |

###### **풀이법**

우선 2부터 16까지 중 어떤 숫자가 진법으로 들어올 지 모르니까 처리를 해주어야한다.

```java
while (num != 0) {
    if (num % n >= 10) numStr += String.valueOf((char) (num % n + 55));
    else numStr += String.valueOf(num % n);
    num /= n;
}
```

위와 같이 어떤 숫자가 들어와도 n진수로 numStr에 더해주는 방식을 사용했다.

문자열의 길이가 t * m + p가 될때까지 반복문을 돌면서 그만큼의 진수들을 구해준다.

그 후에 튜브의 순서인 p번째만 문자열에서 추출해야하므로 for문을 t만큼 돌면서 `String.valueOf(str.charAt(m * i + p - 1))` 를 활용해 추출했다.

```java
public String solution(int n, int t, int m, int p) {
    String str = "0";
    int count = 0;

    while (str.length() < (t * m + p)) {
        String numStr = "";
        int num = count++;

        while (num != 0) {
            if (num % n >= 10) numStr += String.valueOf((char) (num % n + 55));
            else numStr += String.valueOf(num % n);
            num /= n;
        }
        str += new StringBuilder(numStr).reverse().toString();
    }
    String answer = "";
    for (int i = 0; i < t; i++) {
        answer += String.valueOf(str.charAt(m * i + p - 1));
    }
    return answer;
}
```

-----

3. **비밀 지도 [17681](https://programmers.co.kr/learn/courses/30/lessons/17681)**

###### **문제 설명**

네오는 평소 프로도가 비상금을 숨겨놓는 장소를 알려줄 비밀지도를 손에 넣었다. 그런데 이 비밀지도는 숫자로 암호화되어 있어 위치를 확인하기 위해서는 암호를 해독해야 한다. 다행히 지도 암호를 해독할 방법을 적어놓은 메모도 함께 발견했다.

1. 지도는 한 변의 길이가 `n`인 정사각형 배열 형태로, 각 칸은 공백(" ) 또는벽(#") 두 종류로 이루어져 있다.
2. 전체 지도는 두 장의 지도를 겹쳐서 얻을 수 있다. 각각 지도 1과 지도 2라고 하자. 지도 1 또는 지도 2 중 어느 하나라도 벽인 부분은 전체 지도에서도 벽이다. 지도 1과 지도 2에서 모두 공백인 부분은 전체 지도에서도 공백이다.
3. 지도 1과 지도 2는 각각 정수 배열로 암호화되어 있다.
4. 암호화된 배열은 지도의 각 가로줄에서 벽 부분을 `1`, 공백 부분을 `0`으로 부호화했을 때 얻어지는 이진수에 해당하는 값의 배열이다.

![secret map](http://t1.kakaocdn.net/welcome2018/secret8.png)

네오가 프로도의 비상금을 손에 넣을 수 있도록, 비밀지도의 암호를 해독하는 작업을 도와줄 프로그램을 작성하라.

###### **입력 형식**

입력으로 지도의 한 변 크기 `n` 과 2개의 정수 배열 `arr1`, `arr2`가 들어온다.

- 1 ≦ `n` ≦ 16
- `arr1`, `arr2`는 길이 `n`인 정수 배열로 주어진다.
- 정수 배열의 각 원소 `x`를 이진수로 변환했을 때의 길이는 `n` 이하이다. 즉, 0 ≦ `x` ≦ 2n - 1을 만족한다.

###### **출력 형식**

원래의 비밀지도를 해독하여 `'#'`, `공백`으로 구성된 문자열 배열로 출력하라.

###### **입출력 예제**

| 매개변수 | 값                                            |
| -------- | --------------------------------------------- |
| n        | 5                                             |
| arr1     | [9, 20, 28, 18, 11]                           |
| arr2     | [30, 1, 21, 17, 28]                           |
| 출력     | `["#####","# # #", "### #", "# ##", "#####"]` |

| 매개변수 | 값                                                           |
| -------- | ------------------------------------------------------------ |
| n        | 6                                                            |
| arr1     | [46, 33, 33 ,22, 31, 50]                                     |
| arr2     | [27 ,56, 19, 14, 14, 10]                                     |
| 출력     | `["######", "### #", "## ##", " #### ", " #####", "### # "]` |

###### **풀이법**

각 배열의 요소들을 비트 연산자 or로 연산해준 후 2진수로 바꿔준다.

그 후에 1인 곳에는 "#", 0인 곳에는 " "를 치환해주어 answer에 저장해준다.

answer의 요소들 길이가 n보다 작을 경우에는 길이가 같아질 때 까지 answer 요소들 앞부분에 " "을 더해준다.

```java
for (int i = 0; i < n; i++) {
    answer[i] = Integer.toBinaryString(arr1[i] | arr2[i]);
    answer[i] = answer[i].replaceAll("1", "#");
    answer[i] = answer[i].replaceAll("0", " ");
    while (answer[i].length() == n) {
        answer[i] = " " + answer[i];
    }
}
```

----

4. **방문 길이 [49994](https://programmers.co.kr/learn/courses/30/lessons/49994)**

###### **문제 설명**

게임 캐릭터를 4가지 명령어를 통해 움직이려 합니다. 명령어는 다음과 같습니다.

- U: 위쪽으로 한 칸 가기
- D: 아래쪽으로 한 칸 가기
- R: 오른쪽으로 한 칸 가기
- L: 왼쪽으로 한 칸 가기

캐릭터는 좌표평면의 (0, 0) 위치에서 시작합니다. 좌표평면의 경계는 왼쪽 위(-5, 5), 왼쪽 아래(-5, -5), 오른쪽 위(5, 5), 오른쪽 아래(5, -5)로 이루어져 있습니다.



예를 들어, ULURRDLLU로 명령했다면

- 1번 명령어부터 7번 명령어까지 다음과 같이 움직입니다.

- 8번 명령어부터 9번 명령어까지 다음과 같이 움직입니다

이때, 우리는 게임 캐릭터가 지나간 길 중 **캐릭터가 처음 걸어본 길의 길이**를 구하려고 합니다. 예를 들어 위의 예시에서 게임 캐릭터가 움직인 길이는 9이지만, 캐릭터가 처음 걸어본 길의 길이는 7이 됩니다. (8, 9번 명령어에서 움직인 길은 2, 3번 명령어에서 이미 거쳐 간 길입니다)

단, 좌표평면의 경계를 넘어가는 명령어는 무시합니다.

예를 들어, LULLLLLLU로 명령했다면

- 1번 명령어부터 6번 명령어대로 움직인 후, 7, 8번 명령어는 무시합니다. 다시 9번 명령어대로 움직입니다.

이때 캐릭터가 처음 걸어본 길의 길이는 7이 됩니다.

명령어가 매개변수 dirs로 주어질 때, 게임 캐릭터가 처음 걸어본 길의 길이를 구하여 return 하는 solution 함수를 완성해 주세요.

###### **제한사항**

- dirs는 string형으로 주어지며, 'U', 'D', 'R', 'L' 이외에 문자는 주어지지 않습니다.
- dirs의 길이는 500 이하의 자연수입니다.

###### **입출력 예**

| dirs        | answer |
| ----------- | ------ |
| "ULURRDLLU" | 7      |
| "LULLLLLLU" | 7      |

###### **풀이법**

HashMap에 각 방향마다 int 배열을 넣어준다.

그리고 방향이 없이 그냥 길의 중복 여부만 체크해주면 되므로 전 좌표에서 현 좌표, 현 좌표에서 전 좌표 둘 다 set에 넣어주고

set.size/2를 리턴해주었다.

```java
for (Character dir : dirs.toCharArray()) {
    int lastX = x, lastY = y;

    x += map.get(dir)[0];
    y += map.get(dir)[1];

    if (x < -5 || x > 5) {
        x -= map.get(dir)[0];
        continue;
    }
    if (y < -5 || y > 5) {
        y -= map.get(dir)[1];
        continue;
    }

    set.add(lastX + "" + lastY + "" + x + "" + y);
    set.add(x + "" + y + "" + lastX + "" + lastY);
}
```

----

5. **경주로 건설 [67259](https://programmers.co.kr/learn/courses/30/lessons/67259)**

###### **문제 설명**

![kakao_road1.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/384b9e2a-4eb5-460d-bce2-d12359b03b14/kakao_road1.png)

건설회사의 설계사인 `죠르디`는 고객사로부터 자동차 경주로 건설에 필요한 견적을 의뢰받았습니다.
제공된 경주로 설계 도면에 따르면 경주로 부지는 `N x N` 크기의 정사각형 격자 형태이며 각 격자는 `1 x 1` 크기입니다.
설계 도면에는 각 격자의 칸은 `0` 또는 `1` 로 채워져 있으며, `0`은 칸이 비어 있음을 `1`은 해당 칸이 벽으로 채워져 있음을 나타냅니다.
경주로의 출발점은 (0, 0) 칸(좌측 상단)이며, 도착점은 (N-1, N-1) 칸(우측 하단)입니다. 죠르디는 출발점인 (0, 0) 칸에서 출발한 자동차가 도착점인 (N-1, N-1) 칸까지 무사히 도달할 수 있게 중간에 끊기지 않도록 경주로를 건설해야 합니다.
경주로는 상, 하, 좌, 우로 인접한 두 빈 칸을 연결하여 건설할 수 있으며, 벽이 있는 칸에는 경주로를 건설할 수 없습니다.
이때, 인접한 두 빈 칸을 상하 또는 좌우로 연결한 경주로를 `직선 도로` 라고 합니다.
또한 두 `직선 도로`가 서로 직각으로 만나는 지점을 `코너` 라고 부릅니다.
건설 비용을 계산해 보니 `직선 도로` 하나를 만들 때는 100원이 소요되며, `코너`를 하나 만들 때는 500원이 추가로 듭니다.
죠르디는 견적서 작성을 위해 경주로를 건설하는 데 필요한 최소 비용을 계산해야 합니다.

예를 들어, 아래 그림은 `직선 도로` 6개와 `코너` 4개로 구성된 임의의 경주로 예시이며, 건설 비용은 6 x 100 + 4 x 500 = 2600원 입니다.

![kakao_road2.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/0e0911e8-f88e-44fe-8bdc-6856a56df8e0/kakao_road2.png)

또 다른 예로, 아래 그림은 `직선 도로` 4개와 `코너` 1개로 구성된 경주로이며, 건설 비용은 4 x 100 + 1 x 500 = 900원 입니다.

![kakao_road3.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/3f5d9c5e-d7d9-4248-b111-140a0847e741/kakao_road3.png)

------

도면의 상태(0은 비어 있음, 1은 벽)을 나타내는 2차원 배열 board가 매개변수로 주어질 때, 경주로를 건설하는데 필요한 최소 비용을 return 하도록 solution 함수를 완성해주세요.

###### **[제한사항]**

- board는 2차원 정사각 배열로 배열의 크기는 3 이상 25 이하입니다.
- board 배열의 각 원소의 값은 0 또는 1 입니다.
  - 도면의 가장 왼쪽 상단 좌표는 (0, 0)이며, 가장 우측 하단 좌표는 (N-1, N-1) 입니다.
  - 원소의 값 0은 칸이 비어 있어 도로 연결이 가능함을 1은 칸이 벽으로 채워져 있어 도로 연결이 불가능함을 나타냅니다.
- board는 항상 출발점에서 도착점까지 경주로를 건설할 수 있는 형태로 주어집니다.
- 출발점과 도착점 칸의 원소의 값은 항상 0으로 주어집니다.

###### **입출력 예**

| board                                                        | result |
| ------------------------------------------------------------ | ------ |
| [[0,0,0],[0,0,0],[0,0,0]]                                    | 900    |
| [[0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0],[0,0,0,0,0,1,0,0],[0,0,0,0,1,0,0,0],[0,0,0,1,0,0,0,1],[0,0,1,0,0,0,1,0],[0,1,0,0,0,1,0,0],[1,0,0,0,0,0,0,0]] | 3800   |
| [[0,0,1,0],[0,0,0,0],[0,1,0,1],[1,0,0,0]]                    | 2100   |
| [[0,0,0,0,0,0],[0,1,1,1,1,0],[0,0,1,0,0,0],[1,0,0,1,0,1],[0,1,0,0,0,1],[0,0,0,0,0,0]] | 3200   |

###### **입출력 예에 대한 설명**

* 입출력 예 #1
  본문의 예시와 같습니다.

* 입출력 예 #2

![kakao_road4.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/ccc72e9c-2e22-4a09-a94b-ff057b081a70/kakao_road4.png)

위와 같이 경주로를 건설하면 `직선 도로` 18개, `코너` 4개로 총 3800원이 듭니다.

* 입출력 예 #3

![kakao_road5.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/422e86e0-a7d7-4a09-9b42-2b6218a9b5f0/kakao_road5.png)

위와 같이 경주로를 건설하면 `직선 도로` 6개, `코너` 3개로 총 2100원이 듭니다.

* 입출력 예 #4

![kakao_road6.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/4fe42f47-2592-4cb8-91fb-31d6a6da8639/kakao_road6.png)

붉은색 경로와 같이 경주로를 건설하면 `직선 도로` 12개, `코너` 4개로 총 3200원이 듭니다.
만약, 파란색 경로와 같이 경주로를 건설한다면 `직선 도로` 10개, `코너` 5개로 총 3500원이 들며, 더 많은 비용이 듭니다.

###### **풀이법**

bfs를 활용해서 풀었다.

```java
private void bfs(int x, int y, int sum, int vector) {
    Queue<Road> q = new LinkedList<>();
    q.add(new Road(x, y, sum, vector));
    map[0][0] = 1;

    while (!q.isEmpty()) {
        Road road = q.poll();
        if (road.x == n - 1 && road.y == n - 1) {
            if (minValue > road.sum) minValue = road.sum;
            continue;
        }

        for (int i = 0; i < 4; i++) {
            int nextX = road.x + this.x[i];
            int nextY = road.y + this.y[i];

            if (nextX >= 0 && nextX < n && nextY >= 0 && nextY < n && map[nextX][nextY] != 1) {
                int nextFieldSum = 0;

                if (road.vector == -1 || road.vector == i) nextFieldSum = road.sum + 100;
                else nextFieldSum = road.sum + 600;

                if (map[nextX][nextY] == 0) {
                    map[nextX][nextY] = nextFieldSum;
                    q.add(new Road(nextX, nextY, nextFieldSum, i));
                } else if (map[nextX][nextY] >= nextFieldSum) {
                    map[nextX][nextY] = nextFieldSum;
                    q.add(new Road(nextX, nextY, nextFieldSum, i));
                }
            }
        }
    }
}
```

