## 2020년 10월 4주차 알고리즘

1. **쿼드 압축 후 개수 세기 [68936](https://programmers.co.kr/learn/courses/30/lessons/68936)**

###### **문제 설명**

0과 1로 이루어진 2n x 2n 크기의 2차원 정수 배열 arr이 있습니다. 당신은 이 arr을 [쿼드 트리](https://en.wikipedia.org/wiki/Quadtree)와 같은 방식으로 압축하고자 합니다. 구체적인 방식은 다음과 같습니다.

1. 당신이 압축하고자 하는 특정 영역을 S라고 정의합니다.
2. 만약 S 내부에 있는 모든 수가 같은 값이라면, S를 해당 수 하나로 압축시킵니다.
3. 그렇지 않다면, S를 정확히 4개의 균일한 정사각형 영역(입출력 예를 참고해주시기 바랍니다.)으로 쪼갠 뒤, 각 정사각형 영역에 대해 같은 방식의 압축을 시도합니다.

arr이 매개변수로 주어집니다. 위와 같은 방식으로 arr을 압축했을 때, 배열에 최종적으로 남는 0의 개수와 1의 개수를 배열에 담아서 return 하도록 solution 함수를 완성해주세요.

###### **제한사항**

- arr의 행의 개수는 1 이상 1024 이하이며, 2의 거듭 제곱수 형태를 하고 있습니다. 즉, arr의 행의 개수는 1, 2, 4, 8, ..., 1024 중 하나입니다.
  - arr의 각 행의 길이는 arr의 행의 개수와 같습니다. 즉, arr은 정사각형 배열입니다.
  - arr의 각 행에 있는 모든 값은 0 또는 1 입니다.

###### **입출력 예**

| arr                                                          | result    |
| ------------------------------------------------------------ | --------- |
| `[[1,1,0,0],[1,0,0,0],[1,0,0,1],[1,1,1,1]]`                  | `[4,9]`   |
| `[[1,1,1,1,1,1,1,1],[0,1,1,1,1,1,1,1],[0,0,0,0,1,1,1,1],[0,1,0,0,1,1,1,1],[0,0,0,0,0,0,1,1],[0,0,0,0,0,0,0,1],[0,0,0,0,1,0,0,1],[0,0,0,0,1,1,1,1]]` | `[10,15]` |

###### **입출력 예 설명**

**입출력 예 #1**

- 다음 그림은 주어진 arr을 압축하는 과정을 나타낸 것입니다.
- ![ex1.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/d6900862-8be4-4610-aaef-bc8efd5650cf/ex1.png)
- 최종 압축 결과에 0이 4개, 1이 9개 있으므로, `[4,9]`를 return 해야 합니다.

**입출력 예 #2**

- 다음 그림은 주어진 arr을 압축하는 과정을 나타낸 것입니다.
- ![ex2.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/952a05b7-5157-4211-82d9-02845c187e13/ex2.png)
- 최종 압축 결과에 0이 10개, 1이 15개 있으므로, `[10,15]`를 return 해야 합니다.

###### **풀이법**

정사각형을 1/4로 나누어나가면서 조각이 같은 값을 갖고 있으면 압축하고 마지막에 0또는 1을 리턴한다.

```java
private static void dfs(int n, int x, int y) {
    if (n == 1) { // 한개인 경우 해당 값 +
        if (map[x][y] == 1) {
            one++;
        } else {
            zero++;
        }
        return;
    }
    if (isSame(n, x, y)) { //같은값인지 압축 가능한지
        return;
    }
    //4개 분리 탐색
    dfs(n / 2, x, y);
    dfs(n / 2, x + n / 2, y);
    dfs(n / 2, x, y + n / 2);
    dfs(n / 2, x + n / 2, y + n / 2);
}
```

-----

2. **n진수 게임 [17687](https://programmers.co.kr/learn/courses/30/lessons/17687)**

###### **문제 설명**

튜브가 활동하는 코딩 동아리에서는 전통적으로 해오는 게임이 있다. 이 게임은 여러 사람이 둥글게 앉아서 숫자를 하나씩 차례대로 말하는 게임인데, 규칙은 다음과 같다.

1. 숫자를 0부터 시작해서 차례대로 말한다. 첫 번째 사람은 0, 두 번째 사람은 1, … 열 번째 사람은 9를 말한다.
2. 10 이상의 숫자부터는 한 자리씩 끊어서 말한다. 즉 열한 번째 사람은 10의 첫 자리인 1, 열두 번째 사람은 둘째 자리인 0을 말한다.

이렇게 게임을 진행할 경우,
`0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 0, 1, 1, 1, 2, 1, 3, 1, 4, …`
순으로 숫자를 말하면 된다.

한편 코딩 동아리 일원들은 컴퓨터를 다루는 사람답게 이진수로 이 게임을 진행하기도 하는데, 이 경우에는
`0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, …`
순으로 숫자를 말하면 된다.

이진수로 진행하는 게임에 익숙해져 질려가던 사람들은 좀 더 난이도를 높이기 위해 이진법에서 십육진법까지 모든 진법으로 게임을 진행해보기로 했다. 숫자 게임이 익숙하지 않은 튜브는 게임에 져서 벌칙을 받는 굴욕을 피하기 위해, 자신이 말해야 하는 숫자를 스마트폰에 미리 출력해주는 프로그램을 만들려고 한다. 튜브의 프로그램을 구현하라.

###### **입력 형식**

진법 `n`, 미리 구할 숫자의 갯수 `t`, 게임에 참가하는 인원 `m`, 튜브의 순서 `p` 가 주어진다.

- 2 ≦ `n` ≦ 16
- 0 ＜ `t` ≦ 1000
- 2 ≦ `m` ≦ 100
- 1 ≦ `p` ≦ `m`

###### **출력 형식**

튜브가 말해야 하는 숫자 `t`개를 공백 없이 차례대로 나타낸 문자열. 단, `10`~`15`는 각각 대문자 `A`~`F`로 출력한다.

###### **입출력 예제**

| n    | t    | m    | p    | result           |
| ---- | ---- | ---- | ---- | ---------------- |
| 2    | 4    | 2    | 1    | 0111             |
| 16   | 16   | 2    | 1    | 02468ACE11111111 |
| 16   | 16   | 2    | 2    | 13579BDF01234567 |

###### **풀이법**

우선 2부터 16까지 중 어떤 숫자가 진법으로 들어올 지 모르니까 처리를 해주어야한다.

```java
while (num != 0) {
    if (num % n >= 10) numStr += String.valueOf((char) (num % n + 55));
    else numStr += String.valueOf(num % n);
    num /= n;
}
```

위와 같이 어떤 숫자가 들어와도 n진수로 numStr에 더해주는 방식을 사용했다.

문자열의 길이가 t * m + p가 될때까지 반복문을 돌면서 그만큼의 진수들을 구해준다.

그 후에 튜브의 순서인 p번째만 문자열에서 추출해야하므로 for문을 t만큼 돌면서 `String.valueOf(str.charAt(m * i + p - 1))` 를 활용해 추출했다.

```java
public String solution(int n, int t, int m, int p) {
    String str = "0";
    int count = 0;

    while (str.length() < (t * m + p)) {
        String numStr = "";
        int num = count++;

        while (num != 0) {
            if (num % n >= 10) numStr += String.valueOf((char) (num % n + 55));
            else numStr += String.valueOf(num % n);
            num /= n;
        }
        str += new StringBuilder(numStr).reverse().toString();
    }
    String answer = "";
    for (int i = 0; i < t; i++) {
        answer += String.valueOf(str.charAt(m * i + p - 1));
    }
    return answer;
}
```

-----

3. **비밀 지도 [17681](https://programmers.co.kr/learn/courses/30/lessons/17681)**

###### **문제 설명**

네오는 평소 프로도가 비상금을 숨겨놓는 장소를 알려줄 비밀지도를 손에 넣었다. 그런데 이 비밀지도는 숫자로 암호화되어 있어 위치를 확인하기 위해서는 암호를 해독해야 한다. 다행히 지도 암호를 해독할 방법을 적어놓은 메모도 함께 발견했다.

1. 지도는 한 변의 길이가 `n`인 정사각형 배열 형태로, 각 칸은 공백(" ) 또는벽(#") 두 종류로 이루어져 있다.
2. 전체 지도는 두 장의 지도를 겹쳐서 얻을 수 있다. 각각 지도 1과 지도 2라고 하자. 지도 1 또는 지도 2 중 어느 하나라도 벽인 부분은 전체 지도에서도 벽이다. 지도 1과 지도 2에서 모두 공백인 부분은 전체 지도에서도 공백이다.
3. 지도 1과 지도 2는 각각 정수 배열로 암호화되어 있다.
4. 암호화된 배열은 지도의 각 가로줄에서 벽 부분을 `1`, 공백 부분을 `0`으로 부호화했을 때 얻어지는 이진수에 해당하는 값의 배열이다.

![secret map](http://t1.kakaocdn.net/welcome2018/secret8.png)

네오가 프로도의 비상금을 손에 넣을 수 있도록, 비밀지도의 암호를 해독하는 작업을 도와줄 프로그램을 작성하라.

###### **입력 형식**

입력으로 지도의 한 변 크기 `n` 과 2개의 정수 배열 `arr1`, `arr2`가 들어온다.

- 1 ≦ `n` ≦ 16
- `arr1`, `arr2`는 길이 `n`인 정수 배열로 주어진다.
- 정수 배열의 각 원소 `x`를 이진수로 변환했을 때의 길이는 `n` 이하이다. 즉, 0 ≦ `x` ≦ 2n - 1을 만족한다.

###### **출력 형식**

원래의 비밀지도를 해독하여 `'#'`, `공백`으로 구성된 문자열 배열로 출력하라.

###### **입출력 예제**

| 매개변수 | 값                                            |
| -------- | --------------------------------------------- |
| n        | 5                                             |
| arr1     | [9, 20, 28, 18, 11]                           |
| arr2     | [30, 1, 21, 17, 28]                           |
| 출력     | `["#####","# # #", "### #", "# ##", "#####"]` |

| 매개변수 | 값                                                           |
| -------- | ------------------------------------------------------------ |
| n        | 6                                                            |
| arr1     | [46, 33, 33 ,22, 31, 50]                                     |
| arr2     | [27 ,56, 19, 14, 14, 10]                                     |
| 출력     | `["######", "### #", "## ##", " #### ", " #####", "### # "]` |

###### **풀이법**

각 배열의 요소들을 비트 연산자 or로 연산해준 후 2진수로 바꿔준다.

그 후에 1인 곳에는 "#", 0인 곳에는 " "를 치환해주어 answer에 저장해준다.

answer의 요소들 길이가 n보다 작을 경우에는 길이가 같아질 때 까지 answer 요소들 앞부분에 " "을 더해준다.

```java
for (int i = 0; i < n; i++) {
    answer[i] = Integer.toBinaryString(arr1[i] | arr2[i]);
    answer[i] = answer[i].replaceAll("1", "#");
    answer[i] = answer[i].replaceAll("0", " ");
    while (answer[i].length() == n) {
        answer[i] = " " + answer[i];
    }
}
```

