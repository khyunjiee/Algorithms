## 2020년 10월 4주차 알고리즘

1. **쿼드 압축 후 개수 세기 [68936](https://programmers.co.kr/learn/courses/30/lessons/68936)**

###### **문제 설명**

0과 1로 이루어진 2n x 2n 크기의 2차원 정수 배열 arr이 있습니다. 당신은 이 arr을 [쿼드 트리](https://en.wikipedia.org/wiki/Quadtree)와 같은 방식으로 압축하고자 합니다. 구체적인 방식은 다음과 같습니다.

1. 당신이 압축하고자 하는 특정 영역을 S라고 정의합니다.
2. 만약 S 내부에 있는 모든 수가 같은 값이라면, S를 해당 수 하나로 압축시킵니다.
3. 그렇지 않다면, S를 정확히 4개의 균일한 정사각형 영역(입출력 예를 참고해주시기 바랍니다.)으로 쪼갠 뒤, 각 정사각형 영역에 대해 같은 방식의 압축을 시도합니다.

arr이 매개변수로 주어집니다. 위와 같은 방식으로 arr을 압축했을 때, 배열에 최종적으로 남는 0의 개수와 1의 개수를 배열에 담아서 return 하도록 solution 함수를 완성해주세요.

###### **제한사항**

- arr의 행의 개수는 1 이상 1024 이하이며, 2의 거듭 제곱수 형태를 하고 있습니다. 즉, arr의 행의 개수는 1, 2, 4, 8, ..., 1024 중 하나입니다.
  - arr의 각 행의 길이는 arr의 행의 개수와 같습니다. 즉, arr은 정사각형 배열입니다.
  - arr의 각 행에 있는 모든 값은 0 또는 1 입니다.

###### **입출력 예**

| arr                                                          | result    |
| ------------------------------------------------------------ | --------- |
| `[[1,1,0,0],[1,0,0,0],[1,0,0,1],[1,1,1,1]]`                  | `[4,9]`   |
| `[[1,1,1,1,1,1,1,1],[0,1,1,1,1,1,1,1],[0,0,0,0,1,1,1,1],[0,1,0,0,1,1,1,1],[0,0,0,0,0,0,1,1],[0,0,0,0,0,0,0,1],[0,0,0,0,1,0,0,1],[0,0,0,0,1,1,1,1]]` | `[10,15]` |

###### **입출력 예 설명**

**입출력 예 #1**

- 다음 그림은 주어진 arr을 압축하는 과정을 나타낸 것입니다.
- ![ex1.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/d6900862-8be4-4610-aaef-bc8efd5650cf/ex1.png)
- 최종 압축 결과에 0이 4개, 1이 9개 있으므로, `[4,9]`를 return 해야 합니다.

**입출력 예 #2**

- 다음 그림은 주어진 arr을 압축하는 과정을 나타낸 것입니다.
- ![ex2.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/952a05b7-5157-4211-82d9-02845c187e13/ex2.png)
- 최종 압축 결과에 0이 10개, 1이 15개 있으므로, `[10,15]`를 return 해야 합니다.

###### **풀이법**

정사각형을 1/4로 나누어나가면서 조각이 같은 값을 갖고 있으면 압축하고 마지막에 0또는 1을 리턴한다.

```java
private static void dfs(int n, int x, int y) {
    if (n == 1) { // 한개인 경우 해당 값 +
        if (map[x][y] == 1) {
            one++;
        } else {
            zero++;
        }
        return;
    }
    if (isSame(n, x, y)) { //같은값인지 압축 가능한지
        return;
    }
    //4개 분리 탐색
    dfs(n / 2, x, y);
    dfs(n / 2, x + n / 2, y);
    dfs(n / 2, x, y + n / 2);
    dfs(n / 2, x + n / 2, y + n / 2);
}
```

-----

2. **n진수 게임 [17687](https://programmers.co.kr/learn/courses/30/lessons/17687)**

###### **문제 설명**

튜브가 활동하는 코딩 동아리에서는 전통적으로 해오는 게임이 있다. 이 게임은 여러 사람이 둥글게 앉아서 숫자를 하나씩 차례대로 말하는 게임인데, 규칙은 다음과 같다.

1. 숫자를 0부터 시작해서 차례대로 말한다. 첫 번째 사람은 0, 두 번째 사람은 1, … 열 번째 사람은 9를 말한다.
2. 10 이상의 숫자부터는 한 자리씩 끊어서 말한다. 즉 열한 번째 사람은 10의 첫 자리인 1, 열두 번째 사람은 둘째 자리인 0을 말한다.

이렇게 게임을 진행할 경우,
`0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 0, 1, 1, 1, 2, 1, 3, 1, 4, …`
순으로 숫자를 말하면 된다.

한편 코딩 동아리 일원들은 컴퓨터를 다루는 사람답게 이진수로 이 게임을 진행하기도 하는데, 이 경우에는
`0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, …`
순으로 숫자를 말하면 된다.

이진수로 진행하는 게임에 익숙해져 질려가던 사람들은 좀 더 난이도를 높이기 위해 이진법에서 십육진법까지 모든 진법으로 게임을 진행해보기로 했다. 숫자 게임이 익숙하지 않은 튜브는 게임에 져서 벌칙을 받는 굴욕을 피하기 위해, 자신이 말해야 하는 숫자를 스마트폰에 미리 출력해주는 프로그램을 만들려고 한다. 튜브의 프로그램을 구현하라.

###### **입력 형식**

진법 `n`, 미리 구할 숫자의 갯수 `t`, 게임에 참가하는 인원 `m`, 튜브의 순서 `p` 가 주어진다.

- 2 ≦ `n` ≦ 16
- 0 ＜ `t` ≦ 1000
- 2 ≦ `m` ≦ 100
- 1 ≦ `p` ≦ `m`

###### **출력 형식**

튜브가 말해야 하는 숫자 `t`개를 공백 없이 차례대로 나타낸 문자열. 단, `10`~`15`는 각각 대문자 `A`~`F`로 출력한다.

###### **입출력 예제**

| n    | t    | m    | p    | result           |
| ---- | ---- | ---- | ---- | ---------------- |
| 2    | 4    | 2    | 1    | 0111             |
| 16   | 16   | 2    | 1    | 02468ACE11111111 |
| 16   | 16   | 2    | 2    | 13579BDF01234567 |

###### **풀이법**

우선 2부터 16까지 중 어떤 숫자가 진법으로 들어올 지 모르니까 처리를 해주어야한다.

```java
while (num != 0) {
    if (num % n >= 10) numStr += String.valueOf((char) (num % n + 55));
    else numStr += String.valueOf(num % n);
    num /= n;
}
```

위와 같이 어떤 숫자가 들어와도 n진수로 numStr에 더해주는 방식을 사용했다.

문자열의 길이가 t * m + p가 될때까지 반복문을 돌면서 그만큼의 진수들을 구해준다.

그 후에 튜브의 순서인 p번째만 문자열에서 추출해야하므로 for문을 t만큼 돌면서 `String.valueOf(str.charAt(m * i + p - 1))` 를 활용해 추출했다.

```java
public String solution(int n, int t, int m, int p) {
    String str = "0";
    int count = 0;

    while (str.length() < (t * m + p)) {
        String numStr = "";
        int num = count++;

        while (num != 0) {
            if (num % n >= 10) numStr += String.valueOf((char) (num % n + 55));
            else numStr += String.valueOf(num % n);
            num /= n;
        }
        str += new StringBuilder(numStr).reverse().toString();
    }
    String answer = "";
    for (int i = 0; i < t; i++) {
        answer += String.valueOf(str.charAt(m * i + p - 1));
    }
    return answer;
}
```